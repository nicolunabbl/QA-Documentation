El plan de pruebas se basarÃ¡ en un enfoque incremental y basado en riesgos. Contempla las siguientes actividades:

## 5.1 Tipos y niveles de pruebas âš™ï¸

1. **Pruebas unitarias** â€“ realizadas por los desarrolladores para validar funciones aisladas. Deben cubrir la lÃ³gica de negocio y casos de borde utilizando mocks y stubs, con herramientas como Jest o Vitest.
    
2. **Pruebas de integraciÃ³n** â€“ verificar la interacciÃ³n entre componentes (API, base de datos) mediante Postman, RestAssured o bibliotecas equivalentes.
    
3. **Pruebas de sistema (E2E)** â€“ validar los flujos completos del usuario (reserva, cancelaciÃ³n, visualizaciÃ³n de reportes). Se ejecutarÃ¡n con Playwright en el entorno de QA.
    
    1. **Pruebas de aceptaciÃ³n**(Por ahora esta metodologia SCRUM no se tendra en cuenta) â€“ permitirÃ¡n al Product Owner validar que los criterios de negocio se cumplen utilizando historias de usuario y escenarios BDD.
        
4. **Pruebas no funcionales** â€“ pruebas de rendimiento (load/stress), usabilidad y accesibilidad se planificarÃ¡n para fases posteriores.
    

## 5.2 PriorizaciÃ³n y planificaciÃ³n ğŸ“Œ

- ğŸ”º **PriorizaciÃ³n por riesgo**: asignar mayor prioridad a mÃ³dulos crÃ­ticos como reservas y autenticaciÃ³n.
    
- ğŸ’¼ **Valor de negocio**: priorizar funcionalidades con mayor impacto en el cliente (p.â€¯ej. disponibilidad y cancelaciÃ³n).
    
- ğŸ§° **Historial de fallos**: revisar errores previamente reportados y ajustar los casos de prueba.
    
- ğŸ”„ **Volatilidad de requisitos**: considerar cambios frecuentes en funcionalidades nuevas para ajustar la cobertura.
    

ğŸ—“ï¸ El cronograma se organizarÃ¡ en sprints. Cada historia de usuario debe incluir actividades de QA en la estimaciÃ³n. Las pruebas unitarias y de integraciÃ³n se ejecutarÃ¡n en cada commit (shiftâ€‘left), mientras que las pruebas E2E se programarÃ¡n en la pipeline de CI/CD. Las pruebas exploratorias se planificarÃ¡n al final de cada sprint para detectar defectos no cubiertos.

ğŸ“ (Por ahora este plan es una propuesta hasta que tengamos el aprobado de metodologia SCRUM, por el momento solo haremos exploratorias y E2E manuales).

## 5.3 DiseÃ±o de casos y escenarios ğŸ§©

Se utilizarÃ¡n tÃ©cnicas de diseÃ±o como particiÃ³n de equivalencia y anÃ¡lisis de valores lÃ­mite para optimizar el nÃºmero de pruebas. Cada caso de prueba seguirÃ¡ una plantilla estÃ¡ndar con los campos mencionados en la secciÃ³n 6 (ID, tÃ­tulo, mÃ³dulo, pasos, datos, resultado esperado, resultado actual, evidencias y severidad). Se mantendrÃ¡ una matriz de trazabilidad para garantizar cobertura de requisitos.

## 5.4 Herramientas y automatizaciÃ³n ğŸ¤–

Para las pruebas automatizadas se usarÃ¡ la herramienta Playwright segÃºn compatibilidad de lenguaje, modelo de ejecuciÃ³n y capacidad de depuraciÃ³n. Se definirÃ¡ un framework por capas o modular (Page Objects, utilidades comunes). La integraciÃ³n con Jenkins o GitLab CI permitirÃ¡ ejecutar pruebas en cada merge request, recolectar reportes y generar notificaciones.

## 5.5 GestiÃ³n de defectos ğŸ

Los defectos se reportarÃ¡n en una herramienta centralizada con un tÃ­tulo claro y estandarizado, pasos para reproducir, resultado actual y esperado, entorno, evidencias y clasificaciÃ³n de severidad/prioridad. El ciclo de vida del bug (detecciÃ³n, reporte, asignaciÃ³n, correcciÃ³n, verificaciÃ³n, cierre) serÃ¡ seguido estrictamente, y los defectos de severidad _Critical_ o _High_ deberÃ¡n resolverse antes del despliegue.